# TRIPPPIN
### (fourth release)

This is a game based on a commercial board game that was called TRIPPPLES®, which was marketed by some game company years ago, maybe Aladdin.  I have since learned that the game was invented by a William T. Powers, but I did not know that at the time I coded this.  This version is based solely on a distant memory of having played the game back in the seventies or whenever it was; I may not even have reconstructed it accurately.  The remaining notes below are as I wrote them at the time:

The game is played on an eight by eight grid of square tiles which are placed in random positions except for six special ones that go in fixed positions.  There are two players, each having one playing token that moves from square to square.  They start side by side on two tiles with square shapes in them, in the middle of the bottom edge of the board.  The four other fixed squares are marked with circles, and they are located near each corner of the board, one square inward from the edges.  The object of the game is to move your piece from the starting square to the nearest circle, from there to the circle above that, across the top to the opposite circle, down the other side to the circle nearest where your opponent started, and finally to the square your opponent started on.  Whoever gets around the course first wins.  A move consists of moving your piece to one of the eight squares immediately next to it, vertically, horizontally, or diagonally.

The tricky (and fun) part is this:  most of the other squares have arrows marked on them.  Each has arrows pointing in three directions, out of eight possible directions (up, upper right, right, lower right, etc).  These arrows limit the directions in which YOUR OPPONENT is allowed to move, when you are on that square.  If you make a move onto a square that has arrow pointing downward, leftward, and to the upper right, then the only moves your opponent is allowed to make in response are to the squares immediately downward, leftward, or to the upper right of the square he's on.

When you are on a square that does not have arrows (the two starting squares, the four circles, or two blank squares which are randomly placed), then your opponent can make any of the eight moves.  BUT he cannot move off the edge of the board, and he cannot move onto the same square you are on.  So the number of legal moves available is often less than the eight or three allowed by the other player's square.  In fact sometimes a player is left with no legal move at all.  In this case the other player wins.  Strategically, it is dangerous to be on the edge of the board, especially to be in a corner, because of the possibility that your opponent might find a move which "pushes you off the edge", leaving no legal moves.

To play the game, run the program TRIPPPIN from Workbench or CLI.  There are two startup argument you can specify by command line or tool type.  The template is `DIFFICULTY/N,PUBSCREEN`.  The difficulty argument should be a number from 1 to 9, which will be the initial setting of the game's difficulty level, which by default is 3.  To specify a different difficulty on the command line, you can go, for instance, `Tripppin difficulty 5` or just `Tripppin 7`.  For Workbench starting, add a tool type to its icon such as `DIFFICULTY=5` with the Workbench's "Information" command.

You can also specify the name of a public screen on the command line, for instance with `Tripppin pubscreen MyScreenName`, or with a tool type in its icon such as `PUBSCREEN=MyScreenName`, and its window will open on the named screen if it exists, or the default public screen (usually the Workbench) if the named one can't be used.

When started, it will open a fairly large window with a grid of 64 squares in it, and fill in the squares with a random arrangement of arrows, three arrows per square.  Each possible combination of three arrows out of a possible eight is present exactly once.  The program will automatically detect whether the workbench screen is interlaced or not, and adjust the proportions of the squares to suit.  It will show the two pieces on the starting squares, and will show the present status of the game to the right of the board.  At the top it shows whose turn it is to move.  This is indicated by the color of the piece.  They are the same shape but different colors.  On a four color screen the left piece is color 0 and the right one is color 3 (gray and blue in the default Workbench palette) and on an eight color screen they use pens 6 and 5.

To the right of the 64 squares is an information area.  At the top of it, an image of the piece that is to move next is shown beside the words "To move:".  Below that it says either "MAKE A MOVE" or "thinking..."  depending on whether the piece to move next is controlled by a human player or by the computer.  This is written on a background of the color of the piece due to move.  This text can also read "CAN'T MOVE!" if a player has no legal move, or "Game over" if the other player reaches the final goal.

Below that it shows the directions in which this piece can legally move, displayed as a set of arrows similar to a square of the board.  Below that it says "Try to reach the flashing X of your piece's color."  Two X's, one the color of each piece, are blinking on the circles that the pieces have to reach.  When you reach the circle that X is blinking in, it moves to the next circle you have to get to, or to the square your opponent started on if you have reached the last circle.  If you reach that, you win.  When someone wins the area where the words "Try to reach the flashing X ..." were gets filled in with an announcement of who won.

To move a piece, click the mouse on it and drag it to the square you want to move to.  If the move is illegal, the screen will flash ("beep") and the piece will go back where it was.  Otherwise it becomes the other player's turn.

When the game first starts, the right hand piece is under human control and the other piece is played by the computer.  When your piece is moved the computer will think a bit and then move the other one.  How long it thinks depends on the difficulty level you set.

Control of the difficulty level, and of whether each piece is human or computer controlled, is done with a menu.  The menu contains first an item with an image of each piece, with a submenu that lets you pick "Human" or "Computer", with a checkmark showing the current selection.  Then there's an item for difficulty level, with a submenu giving you choices from one (easy) to nine (takes a long time to think).  The level starts at three, unless you specify a different number with a command line or tool type argument (see above).  A checkmark shows the current level.  The computer uses a simple lookahead strategy.  At level one it looks at each move only to see which move gets it closest to its goal.  At level two it looks at how close you can get for each move it makes.  At level three it checks how close it can get after each move you might make in response to each of its possible moves.  And so on.  The higher the level you set, the longer it takes to think, though the delay is hardly noticeable below level five or six.  It is possible that because of the way it works, the even numbered levels may play a somewhat more defense-oriented style than the odd numbered ones.

Don't be discouraged if you have a hard time beating even a moderate difficulty level; I do too.  Most human players hardly look further than
level two (if that) most of the time anyway.  Often a moderate level setting plays about as well as a high level one.

The next menu item lets you choose whether the computer player is allowed to repeat a sequence of moves forever.  If "Prevent loops" is checked, then if recent moves by both sides have been repeated two complete times in a loop, the computer player is not allowed to continue another repetition unless there is no other legal move.  Loops more than twenty turns long will not be noticed.  There is no restriction of looping for human players.  If you set the computer to play against itself loop prevention is essential or it will probably get stuck before finishing a game.  If you want to play against the toughest possible computer opponent then turn off loop prevention, because otherwise, by getting the computer into a loop, you can force it to make inferior moves.

Below that is "Suggest a move", with keyboard shortcut right-Amiga S.  When you select this (if it is not the computer's turn) it will show you which square would be the best move for you, in its opinion.  How good a suggestion this is depends on how long you wait before asking.  Even if you only wait a couple of seconds it will probably give you an answer based on looking at least six levels ahead.  It will show the suggested square with a bunch of colored dots moving around a square outline.  "Tripppin Has Ants."

Below that on the menu is the option to take back your last move.  You can use the keyboard shortcut right-Amiga T for this.  It undoes the last move made by a human controlled piece, and any computer move made after it.  Pressing it again undoes the move before, and so on.  A maximum of forty moves can be undone.  Nothing happens if both pieces are being played by computer.

Below that is "Start a new game", keyboard shortcut right-Amiga N.  It will reshuffle the arrow squares and put the pieces in their starting positions.  This time the other piece moves first -- it changes each time you restart.  Settings of difficulty level and human/computer control of each piece remain unchanged.

Last is "Quit the game", with shortcut right-Amiga Q.  You can also quit by clicking the closebox or, if it was run from CLI, by pressing Ctrl-C in the CLI window it's running from.

Tripppin, unlike many games, has no cosmetic problems with the choice of whether your workbench is interlace or not, or what size fonts you use.  It positions text items based on the size of the font.  (It can manage font sizes up to 13 point, or even 15 a bit clumsily... or double that on an interlaced workbench.)  It takes advantage of an eight color screen if it is opened on one.  And it keeps the vertical and horizontal proportions the same whether the screen is interlaced or not.  It even adapts to screens where the pens where color 1 is light and color 2 is dark, the reverse of the usual convention.

The source code for this game contains plenty of possibly useful example material for Amiga coding.  I wrote it for practice with graphics.library and with intuition event loops (since almost everything else I've been writing is CLI oriented), and it contains useful examples of Bobs, animated sprites (not VSprites though), basic multitasking (the lookahead thinking is done in a separate task so that the main program can be immediately responsive to user input), a tiny interrupt server (not really needed, but still kinda useful), and menu
and mouse input.  This code, though not necessarily the actual game it plays (which I did not invent) is in the public domain.

## REVISION HISTORY:

The fourth release of Tripppin differs from the third mainly in that it can no longer be run under AmigaDOS 1.x -- 2.04 is required.  The
eight color features and the PUBSCREEN option are new in this version, and so is the ability to open on a screen of up to 256 colors instead of just 16 without internal memory problems.  The task priorities have been rearranged to make it more responsive without bogging anything down while waiting for a move and considering possibilities for the "Suggest a move" feature.  Some slight cosmetic changes have been made to colors used in the menu and the margin area to the right of the board.  The images of the playing pieces are a bit more finely detailed now on interlaced screens.  And the distribution of Tripppin 3 left the out the source file "Paul.h" -- apparently a habit of mine, because release 1 left out "trip.h".

The differences between the third release of Tripppin and the second were mostly cosmetic changes; I added the ability to pick either color 1 or color 2 to be "white" with the other being "black", depending on the Workbench screen's palette... also I slightly readjusted the positions and spacings of several items to avoid small glitches visible under 2.0, and I made it hog less CPU.

The differences between this second release and the first were:  two small bugs were fixed, the sprites were more obnoxious before (they didn't turn off when you were doing other stuff), and you couldn't turn off loop prevention in the first version.
